---
title: 'React with i18next'
description: 'Integrate Unlingo with React applications using i18next for powerful internationalization'
---

## Overview

This guide shows how to integrate Unlingo with React applications using i18next, one of the most popular internationalization frameworks. You'll learn how to set up a custom backend that fetches translations from Unlingo and integrates seamlessly with i18next.

## Prerequisites

- React application (Create React App, Vite, or custom setup)
- Basic knowledge of React hooks
- An Unlingo project with translations

## Installation

Install the required dependencies:

<CodeGroup>

```bash npm
npm install i18next react-i18next
```

```bash yarn
yarn add i18next react-i18next
```

```bash pnpm
pnpm add i18next react-i18next
```

</CodeGroup>

## Setting Up the Unlingo Backend

Create a custom i18next backend that fetches translations from Unlingo:

<CodeGroup>

```javascript unlingo-backend.js
class UnlingoBackend {
  constructor(services, backendOptions = {}) {
    this.type = 'backend';
    this.options = {
      apiKey: '',
      version: 'latest',
      baseUrl: 'https://api.unlingo.com/v1',
      ...backendOptions
    };
  }

  init(services, backendOptions = {}) {
    this.services = services;
    this.options = { ...this.options, ...backendOptions };
  }

  async read(language, namespace, callback) {
    try {
      const url = new URL('/translations', this.options.baseUrl);
      url.searchParams.set('version', this.options.version);
      url.searchParams.set('namespace', namespace);
      url.searchParams.set('lang', language);

      const response = await fetch(url.toString(), {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.options.apiKey}`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        return callback(new Error(`HTTP ${response.status}: ${errorData.error || response.statusText}`), null);
      }

      const data = await response.json();
      callback(null, data);
    } catch (error) {
      console.error('Unlingo Backend Error:', error);
      callback(error, null);
    }
  }
}

export default UnlingoBackend;
```

```typescript unlingo-backend.ts
import { BackendModule, ReadCallback, Services } from 'i18next';

interface UnlingoBackendOptions {
  apiKey: string;
  version?: string;
  baseUrl?: string;
}

class UnlingoBackend implements BackendModule {
  static type = 'backend' as const;
  type = 'backend' as const;
  
  private services?: Services;
  private options: Required<UnlingoBackendOptions>;

  constructor(services?: Services, backendOptions: UnlingoBackendOptions = { apiKey: '' }) {
    this.options = {
      apiKey: '',
      version: 'latest',
      baseUrl: 'https://api.unlingo.com/v1',
      ...backendOptions
    };
  }

  init(services: Services, backendOptions: Partial<UnlingoBackendOptions> = {}) {
    this.services = services;
    this.options = { ...this.options, ...backendOptions };
  }

  async read(language: string, namespace: string, callback: ReadCallback) {
    try {
      const url = new URL('/translations', this.options.baseUrl);
      url.searchParams.set('version', this.options.version);
      url.searchParams.set('namespace', namespace);
      url.searchParams.set('lang', language);

      const response = await fetch(url.toString(), {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.options.apiKey}`,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        return callback(new Error(`HTTP ${response.status}: ${errorData.error || response.statusText}`), null);
      }

      const data = await response.json();
      callback(null, data);
    } catch (error) {
      console.error('Unlingo Backend Error:', error);
      callback(error as Error, null);
    }
  }
}

export default UnlingoBackend;
```

</CodeGroup>

## Configuring i18next

Set up i18next with the Unlingo backend:

<CodeGroup>

```javascript i18n.js
import i18next from 'i18next';
import { initReactI18next } from 'react-i18next';
import UnlingoBackend from './unlingo-backend';

// Get API key from environment variables
const UNLINGO_API_KEY = process.env.REACT_APP_UNLINGO_API_KEY;
const UNLINGO_VERSION = process.env.REACT_APP_UNLINGO_VERSION || 'latest';

i18next
  .use(UnlingoBackend)
  .use(initReactI18next)
  .init({
    // Language settings
    lng: 'en', // Default language
    fallbackLng: 'en',
    
    // Namespace settings
    defaultNS: 'common',
    ns: ['common', 'navigation', 'auth'],
    
    // Backend configuration
    backend: {
      apiKey: UNLINGO_API_KEY,
      version: UNLINGO_VERSION,
    },
    
    // React specific options
    react: {
      bindI18n: 'languageChanged',
      bindI18nStore: '',
      transEmptyNodeValue: '',
      transSupportBasicHtmlNodes: true,
      transKeepBasicHtmlNodesFor: ['br', 'strong', 'i'],
    },
    
    // Interpolation settings
    interpolation: {
      escapeValue: false, // React already escapes values
    },
    
    // Development settings
    debug: process.env.NODE_ENV === 'development',
  });

export default i18next;
```

```typescript i18n.ts
import i18next from 'i18next';
import { initReactI18next } from 'react-i18next';
import UnlingoBackend from './unlingo-backend';

// Get API key from environment variables
const UNLINGO_API_KEY = process.env.REACT_APP_UNLINGO_API_KEY || '';
const UNLINGO_VERSION = process.env.REACT_APP_UNLINGO_VERSION || 'latest';

declare module 'i18next' {
  interface CustomTypeOptions {
    defaultNS: 'common';
    resources: {
      common: typeof import('./translations/en/common.json');
      navigation: typeof import('./translations/en/navigation.json');
      auth: typeof import('./translations/en/auth.json');
    };
  }
}

i18next
  .use(UnlingoBackend)
  .use(initReactI18next)
  .init({
    // Language settings
    lng: 'en',
    fallbackLng: 'en',
    
    // Namespace settings
    defaultNS: 'common',
    ns: ['common', 'navigation', 'auth'],
    
    // Backend configuration
    backend: {
      apiKey: UNLINGO_API_KEY,
      version: UNLINGO_VERSION,
    },
    
    // React specific options
    react: {
      bindI18n: 'languageChanged',
      bindI18nStore: '',
      transEmptyNodeValue: '',
      transSupportBasicHtmlNodes: true,
      transKeepBasicHtmlNodesFor: ['br', 'strong', 'i'],
    },
    
    // Interpolation settings
    interpolation: {
      escapeValue: false,
    },
    
    // Development settings
    debug: process.env.NODE_ENV === 'development',
  });

export default i18next;
```

</CodeGroup>

## Environment Variables

Add your Unlingo credentials to your environment file:

```env .env.local
REACT_APP_UNLINGO_API_KEY=your_api_key_here
REACT_APP_UNLINGO_VERSION=1.0.0
```

<Warning>
  Never expose your API key in client-side code for production applications. Consider using a backend proxy for production deployments.
</Warning>

## Initializing in Your App

Import and initialize i18next in your main App component:

<CodeGroup>

```javascript App.js
import React, { Suspense } from 'react';
import './i18n'; // Import i18n configuration
import MainApp from './MainApp';

function App() {
  return (
    <Suspense fallback={<div>Loading translations...</div>}>
      <MainApp />
    </Suspense>
  );
}

export default App;
```

```typescript App.tsx
import React, { Suspense } from 'react';
import './i18n';
import MainApp from './MainApp';

const App: React.FC = () => {
  return (
    <Suspense fallback={<div>Loading translations...</div>}>
      <MainApp />
    </Suspense>
  );
};

export default App;
```

</CodeGroup>

## Using Translations in Components

### Basic Usage

<CodeGroup>

```javascript BasicComponent.js
import React from 'react';
import { useTranslation } from 'react-i18next';

function Header() {
  const { t } = useTranslation('common');

  return (
    <header>
      <h1>{t('welcome')}</h1>
      <p>{t('description')}</p>
    </header>
  );
}

export default Header;
```

```typescript BasicComponent.tsx
import React from 'react';
import { useTranslation } from 'react-i18next';

const Header: React.FC = () => {
  const { t } = useTranslation('common');

  return (
    <header>
      <h1>{t('welcome')}</h1>
      <p>{t('description')}</p>
    </header>
  );
};

export default Header;
```

</CodeGroup>

### With Interpolation

```javascript
function UserGreeting({ username }) {
  const { t } = useTranslation('common');

  return (
    <div>
      <h2>{t('greeting', { name: username })}</h2>
      <p>{t('lastLogin', { date: new Date().toLocaleDateString() })}</p>
    </div>
  );
}

// Translation: "greeting": "Hello, {{name}}!"
// Translation: "lastLogin": "Last login: {{date}}"
```

### Multiple Namespaces

```javascript
function Navigation() {
  const { t } = useTranslation(['navigation', 'common']);

  return (
    <nav>
      <ul>
        <li>{t('navigation:home')}</li>
        <li>{t('navigation:about')}</li>
        <li>{t('navigation:contact')}</li>
      </ul>
      <button>{t('common:buttons.login')}</button>
    </nav>
  );
}
```

### Conditional Translations

```javascript
function ProductCard({ product, isOnSale }) {
  const { t } = useTranslation('products');

  return (
    <div className="product-card">
      <h3>{product.name}</h3>
      <p className="price">
        {isOnSale 
          ? t('salePrice', { price: product.salePrice, original: product.price })
          : t('regularPrice', { price: product.price })
        }
      </p>
      <button>{t('addToCart')}</button>
    </div>
  );
}
```

## Language Switching

Implement language switching functionality:

```javascript
import React from 'react';
import { useTranslation } from 'react-i18next';

function LanguageSwitcher() {
  const { i18n, t } = useTranslation('common');

  const languages = [
    { code: 'en', name: 'English' },
    { code: 'es', name: 'Español' },
    { code: 'fr', name: 'Français' },
    { code: 'de', name: 'Deutsch' },
  ];

  const changeLanguage = (languageCode) => {
    i18n.changeLanguage(languageCode);
  };

  return (
    <div className="language-switcher">
      <label>{t('selectLanguage')}</label>
      <select 
        value={i18n.language} 
        onChange={(e) => changeLanguage(e.target.value)}
      >
        {languages.map((lang) => (
          <option key={lang.code} value={lang.code}>
            {lang.name}
          </option>
        ))}
      </select>
    </div>
  );
}
```

## Advanced Features

### Loading States

Handle loading and error states:

```javascript
import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';

function TranslationProvider({ children }) {
  const { i18n, ready } = useTranslation();
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const handleLoaded = () => {
      setIsLoading(false);
      setError(null);
    };

    const handleFailure = (err) => {
      setIsLoading(false);
      setError(err);
    };

    i18n.on('loaded', handleLoaded);
    i18n.on('failedLoading', handleFailure);

    return () => {
      i18n.off('loaded', handleLoaded);
      i18n.off('failedLoading', handleFailure);
    };
  }, [i18n]);

  if (isLoading && !ready) {
    return <div>Loading translations...</div>;
  }

  if (error) {
    return <div>Error loading translations: {error.message}</div>;
  }

  return children;
}
```

### Caching Strategy

Implement caching to improve performance:

```javascript
// Enhanced backend with caching
class CachedUnlingoBackend extends UnlingoBackend {
  constructor(services, backendOptions = {}) {
    super(services, backendOptions);
    this.cache = new Map();
    this.cacheTimeout = backendOptions.cacheTimeout || 5 * 60 * 1000; // 5 minutes
  }

  async read(language, namespace, callback) {
    const cacheKey = `${language}-${namespace}-${this.options.version}`;
    const cached = this.cache.get(cacheKey);

    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return callback(null, cached.data);
    }

    // Fallback to parent read method
    super.read(language, namespace, (error, data) => {
      if (!error && data) {
        this.cache.set(cacheKey, {
          data,
          timestamp: Date.now()
        });
      }
      callback(error, data);
    });
  }
}
```

### Lazy Loading Namespaces

Load namespaces only when needed:

```javascript
import React, { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';

function DashboardComponent() {
  const { t, i18n } = useTranslation();
  const [dashboardLoaded, setDashboardLoaded] = useState(false);

  useEffect(() => {
    const loadDashboardNamespace = async () => {
      try {
        await i18n.loadNamespaces('dashboard');
        setDashboardLoaded(true);
      } catch (error) {
        console.error('Failed to load dashboard namespace:', error);
      }
    };

    if (!i18n.hasResourceBundle('en', 'dashboard')) {
      loadDashboardNamespace();
    } else {
      setDashboardLoaded(true);
    }
  }, [i18n]);

  if (!dashboardLoaded) {
    return <div>Loading dashboard...</div>;
  }

  return (
    <div>
      <h1>{t('dashboard:title')}</h1>
      <p>{t('dashboard:description')}</p>
    </div>
  );
}
```

## Best Practices

### Component-Scoped Translations

Keep translations close to where they're used:

```javascript
// ProductCard.js
function ProductCard({ product }) {
  // Load only the namespace this component needs
  const { t } = useTranslation('products');
  
  return (
    <div>
      <h3>{t('name')}</h3>
      <p>{t('description')}</p>
    </div>
  );
}
```

### Type Safety (TypeScript)

Define types for your translations:

```typescript
// types/translations.ts
export interface CommonTranslations {
  welcome: string;
  buttons: {
    login: string;
    logout: string;
    submit: string;
  };
  greeting: string;
}

// Component usage
const { t } = useTranslation<'common', CommonTranslations>('common');
```

### Error Boundaries

Wrap your app with error boundaries to handle translation failures gracefully:

```javascript
class TranslationErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Translation error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <div>Something went wrong with translations.</div>;
    }

    return this.props.children;
  }
}
```

## Testing

### Mock the Backend for Testing

```javascript
// __mocks__/unlingo-backend.js
class MockUnlingoBackend {
  constructor() {
    this.type = 'backend';
  }

  init() {}

  read(language, namespace, callback) {
    const mockTranslations = {
      welcome: 'Welcome',
      greeting: 'Hello, {{name}}!',
    };
    
    setTimeout(() => callback(null, mockTranslations), 10);
  }
}

export default MockUnlingoBackend;
```

### Testing Components

```javascript
import { render, screen } from '@testing-library/react';
import { I18nextProvider } from 'react-i18next';
import i18n from '../test-utils/i18n-test'; // Test i18n config
import Header from '../Header';

test('renders welcome message', async () => {
  render(
    <I18nextProvider i18n={i18n}>
      <Header />
    </I18nextProvider>
  );

  expect(await screen.findByText('Welcome')).toBeInTheDocument();
});
```

## Production Considerations

### API Key Security

For production applications, avoid exposing API keys in the frontend:

1. **Backend Proxy** (Recommended): Create an API endpoint in your backend that proxies requests to Unlingo
2. **Build-time Fetching**: Fetch translations during the build process
3. **Server-Side Rendering**: Load translations on the server

### Performance Optimization

- **Bundle Splitting**: Load translations asynchronously
- **Caching**: Implement proper caching strategies
- **CDN**: Use Unlingo's global CDN for optimal performance
- **Preloading**: Preload critical namespaces

## Troubleshooting

<AccordionGroup>
  <Accordion title="Translations not loading">
    Check that:
    - Your API key is correct and has proper permissions
    - The namespace exists in your Unlingo project
    - Network requests are successful (check browser console)
    - The version parameter matches your released version
  </Accordion>
  
  <Accordion title="Missing interpolation values">
    Ensure that:
    - All interpolation variables are provided: `t('key', { variable: value })`
    - Variable names match between your code and translations
    - Values are not undefined or null
  </Accordion>
  
  <Accordion title="CORS errors">
    Unlingo includes CORS headers, but if you're still seeing errors:
    - Check if you're making requests from the correct domain
    - Consider using a backend proxy for production
    - Verify your API key has the correct permissions
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Advanced Caching"
    icon="database"
    href="/advanced/caching"
  >
    Learn advanced caching strategies for better performance
  </Card>
  <Card
    title="Next.js Integration"
    icon="N"
    href="/integrations/next-intl"
  >
    Integrate with Next.js applications using next-intl
  </Card>
</CardGroup>