---
title: 'Authentication'
description: 'Learn how to authenticate with the Unlingo API using API keys'
---

## Overview

Unlingo uses API keys for authentication. Each API key is scoped to a specific project and can have different permission levels. This guide covers how to create, manage, and use API keys securely.

## Creating API Keys

<Steps>
  <Step title="Navigate to Project Settings">
    Go to your project dashboard and click on the "API Keys" tab
  </Step>
  <Step title="Click Create API Key">
    Click the "Create API Key" button to open the creation dialog
  </Step>
  <Step title="Configure Your Key">
    Set up your API key:
    - **Name**: A descriptive name (e.g., "Production API Key")
    - **Environment**: Production, Staging, or Development
    - **Permissions**: Read-only or Read/Write access
    - **Expiration**: Optional expiration date
  </Step>
  <Step title="Save and Copy">
    Click "Create" and immediately copy the generated API key. You won't be able to see it again.
  </Step>
</Steps>

<Warning>
  Store your API keys securely! Once created, the key value cannot be retrieved again. If you lose an API key, you'll need to create a new one.
</Warning>

## API Key Types

### Read-Only Keys
- Can fetch translations and project information
- Cannot modify projects, namespaces, or translations
- Recommended for production applications

### Read/Write Keys
- Full access to create, update, and delete resources
- Should only be used in secure environments
- Recommended for CI/CD pipelines and development

## Using API Keys

### HTTP Headers

Include your API key in the `Authorization` header:

```bash
Authorization: Bearer YOUR_API_KEY
```

### Example Requests

<CodeGroup>

```bash cURL
curl -X GET "https://api.unlingo.com/v1/translations?version=1.0.0&namespace=common&lang=en" \
  -H "Authorization: Bearer ul_1234567890abcdef"
```

```javascript JavaScript
const response = await fetch(
  'https://api.unlingo.com/v1/translations?version=1.0.0&namespace=common&lang=en',
  {
    headers: {
      'Authorization': 'Bearer ul_1234567890abcdef'
    }
  }
);
```

```python Python
import requests

headers = {
    'Authorization': 'Bearer ul_1234567890abcdef'
}

response = requests.get(
    'https://api.unlingo.com/v1/translations',
    headers=headers,
    params={
        'version': '1.0.0',
        'namespace': 'common',
        'lang': 'en'
    }
)
```

```php PHP
$headers = [
    'Authorization: Bearer ul_1234567890abcdef'
];

$url = 'https://api.unlingo.com/v1/translations?' . http_build_query([
    'version' => '1.0.0',
    'namespace' => 'common',
    'lang' => 'en'
]);

$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

$response = curl_exec($ch);
curl_close($ch);
```

</CodeGroup>

## Security Best Practices

### Environment Variables

Never hardcode API keys in your source code. Use environment variables instead:

<CodeGroup>

```javascript React/Next.js
// .env.local
UNLINGO_API_KEY=ul_1234567890abcdef

// In your component or API route
const apiKey = process.env.UNLINGO_API_KEY;
```

```javascript Node.js
// .env
UNLINGO_API_KEY=ul_1234567890abcdef

// In your application
require('dotenv').config();
const apiKey = process.env.UNLINGO_API_KEY;
```

```python Python
# .env
UNLINGO_API_KEY=ul_1234567890abcdef

# In your application
import os
from dotenv import load_dotenv

load_dotenv()
api_key = os.getenv('UNLINGO_API_KEY')
```

</CodeGroup>

### Frontend Applications

<Warning>
  Never expose API keys in client-side JavaScript. They can be easily extracted by anyone viewing your application.
</Warning>

For frontend applications, consider these approaches:

#### Option 1: Server-Side Proxy (Recommended)

Create an API route in your backend that proxies requests to Unlingo:

```javascript Next.js API Route
// pages/api/translations.js or app/api/translations/route.js
export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const version = searchParams.get('version');
  const namespace = searchParams.get('namespace');
  const lang = searchParams.get('lang');
  
  const response = await fetch(
    `https://api.unlingo.com/v1/translations?version=${version}&namespace=${namespace}&lang=${lang}`,
    {
      headers: {
        'Authorization': `Bearer ${process.env.UNLINGO_API_KEY}`
      }
    }
  );
  
  const translations = await response.json();
  return Response.json(translations);
}
```

Then call your own API from the frontend:

```javascript Frontend
const response = await fetch('/api/translations?version=1.0.0&namespace=common&lang=en');
const translations = await response.json();
```

#### Option 2: Build-Time Translation Fetching

Fetch translations at build time and include them in your bundle:

```javascript Next.js
// next.config.js
module.exports = {
  env: {
    TRANSLATIONS: JSON.stringify(await fetchTranslations())
  }
}

async function fetchTranslations() {
  const response = await fetch('https://api.unlingo.com/v1/translations...', {
    headers: { 'Authorization': `Bearer ${process.env.UNLINGO_API_KEY}` }
  });
  return response.json();
}
```

### CI/CD Pipelines

For automated deployments, use read/write API keys with appropriate scoping:

```yaml GitHub Actions
name: Deploy
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Update translations
        env:
          UNLINGO_API_KEY: ${{ secrets.UNLINGO_API_KEY }}
        run: |
          curl -X POST https://api.unlingo.com/v1/releases \
            -H "Authorization: Bearer $UNLINGO_API_KEY" \
            -H "Content-Type: application/json" \
            -d '{"version": "${{ github.sha }}", "description": "Automated release"}'
```

## API Key Management

### Rotating Keys

Regularly rotate your API keys for security:

<Steps>
  <Step title="Create New Key">
    Generate a new API key with the same permissions
  </Step>
  <Step title="Update Applications">
    Update all applications and services to use the new key
  </Step>
  <Step title="Test Thoroughly">
    Verify that all integrations work with the new key
  </Step>
  <Step title="Revoke Old Key">
    Delete the old API key from your project settings
  </Step>
</Steps>

### Key Scoping

Use different API keys for different environments:

- **Production**: Read-only keys for production applications
- **Staging**: Read/write keys for staging environments
- **Development**: Read/write keys for local development
- **CI/CD**: Read/write keys for automated deployments

### Monitoring Usage

Track API key usage in your project dashboard:

- **Request Volume**: Monitor API calls per key
- **Error Rates**: Track failed requests
- **Geographic Distribution**: See where requests originate
- **Rate Limiting**: Understand usage patterns

## Error Handling

### Common Authentication Errors

<AccordionGroup>
  <Accordion title="401 Unauthorized">
    **Cause**: Invalid or missing API key
    
    **Solution**: 
    - Check that your API key is correct
    - Ensure the `Authorization` header is properly formatted
    - Verify the API key hasn't been revoked or expired
  </Accordion>
  
  <Accordion title="403 Forbidden">
    **Cause**: API key lacks required permissions
    
    **Solution**:
    - Check if your key has read/write permissions for the requested operation
    - Verify the key is associated with the correct project
    - Ensure the key hasn't reached its rate limit
  </Accordion>
  
  <Accordion title="429 Too Many Requests">
    **Cause**: Rate limit exceeded
    
    **Solution**:
    - Implement exponential backoff in your requests
    - Consider upgrading your plan for higher rate limits
    - Optimize your request patterns to reduce frequency
  </Accordion>
</AccordionGroup>

### Implementing Retry Logic

```javascript
async function fetchWithRetry(url, options, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      if (response.status === 429) {
        // Rate limited - wait before retrying
        const retryAfter = response.headers.get('Retry-After') || 1;
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        continue;
      }
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }
      
      // Exponential backoff
      const delay = Math.pow(2, attempt) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

## Rate Limits

Unlingo implements rate limiting to ensure fair usage:

| Plan | Requests per minute | Requests per hour |
|------|-------------------|------------------|
| Free | 100 | 1,000 |
| Pro | 1,000 | 10,000 |
| Enterprise | Custom | Custom |

<Tip>
  Implement caching in your application to reduce API calls and stay within rate limits. See our [caching guide](/advanced/caching) for best practices.
</Tip>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="API Reference"
    icon="code"
    href="/api-reference/introduction"
  >
    Explore the complete API documentation
  </Card>
  <Card
    title="SDK Integration"
    icon="puzzle-piece"
    href="/integrations/i18next"
  >
    Use our SDKs for easier integration
  </Card>
</CardGroup>